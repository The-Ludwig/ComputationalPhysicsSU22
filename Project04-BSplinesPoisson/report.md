---
title: Computational Physics -- 4 -- Basic Splines
author:
- Ludwig Neste
header-includes: |
    \usepackage{blindtext}
    \usepackage[section, below]{placeins}
papersize: a4
fontfamily: libertinus
geometry: 
- left=1cm
- right=1cm
- top=2cm
- bottom=2cm
classoption:
- twocolumn
...

# Introduction
The *Poisson* equation determining Electrostatics is 
$$
\nabla^2 V(x) = -\frac{\rho(x)}{\epsilon_0} \overset{\text{gauss. units}} = -4\pi \rho(x).
$$
Where $V(x)$ is the solution to the equation, the electrostatic potential, generated by 
a charge distribution $\rho(x)$. This can be derived from *Maxwell's* equations 
in the case of a vanishing magnetic field. One can for example also check, that one 
successfully regenerates Coloumb's law, if $\rho(x)=e\delta(x)$.

In many situations we know the charge distribution and want to solve Poisson's equation to 
get the potential. This is not necessarily always analyticly solvable, so we might 
have to use numerical methods, as described in the following.


If we are in 3 dimensions and have a rotationally symmetric charge distribution, 
we can transform Poisson's equation into one dimension:
$$
(\partial_x^2+\partial_y^2+\partial_z^2) V(r=|x|) = (\partial_r^2+\frac{2}{r}\partial_r) V(r)= -4\pi \rho(r).
$$
If we substitute $\phi(r)=rV(r)$ this simplifies to 
$$
\partial_r^2 \phi(r) = -4\pi r \rho(r)
$$

The examples we will encounter here are a homogeneously charged sphere 
$$
\rho_{\mathrm{Sphere}}(r) = \begin{cases}
\frac{Q}{V} \quad & r\leq R\\
0 \quad & R < r
\end{cases}
$$
the homogeneously charged shell,
$$
\rho_{\mathrm{Shell}}(r) = \begin{cases}
0 \quad & \phantom{R_2\leq} r < R_1 \\
\frac{Q}{V} \quad & R_1\leq r\leq R_2\\
0 \quad &  R_2 < r
\end{cases}
$$
and the charge density of the electron of the hydrogen atom in the ground state
$$
\rho_{\mathrm{H}}(r) = e \psi^*(r)\psi(r) = \frac{e}{\pi a^3}e^{-2r/a_0}.
$$
Here $e$ is the electron charge and $a_0$ is the Bohr radius.

These three problems have analytical solutions so we can compare them to 
our numerical results:
\begin{align*}
V_{\mathrm{Sphere}}(r) &= 
\begin{cases}
\frac{Q}{2R}\left(3-\left(\frac{r}{R}\right)^2\right) \quad &  r \leq R\\
\frac{Q}{r} \quad &  R < r
\end{cases}\\
V_{\mathrm{Shell}}(r) &= \begin{cases}
\frac{4\pi Q}{2V} \left(R_2^2-R_1^2\right)\quad & \phantom{R_2\leq} r < R_1 \\
\frac{4\pi Q}{2V}\left(\frac{R_2^2}{2}-\frac{1}{3}\left(\frac{R_1^3}{r}+\frac{r^2}{2}\right)\right) \quad & R_1\leq r\leq R_2\\
0 \quad &  R_2 < r
\end{cases}\\
V_{\mathrm{H}}(r) &= e\left(\frac{1}{r}-\mathrm{e}^{-2r}\left(\frac{1}{r}+1\right)\right)
\end{align*}

# Numerical Methods
*BSplines* (*B*asic Splines) are the basis functions for every spline. 
Every spline of order $k$ $S_k(x)$ can be written as a sum of Bsplines of order $k$  $B_{i,k}$:
$$
S_k(x) = \sum_{i = -k}^{N-1} c_i B_{i, k}(x).
$$
We are choosing the indexing convention where $k$ starts at $0$.

BSplines can be defined in the following way by the *Cox-de Boor* recursion formula.
\begin{align*}
B_{i,0}(x)&:= \begin{cases}
 1 & \text{if } t_i \leq x < t_{i+1}, \\
 0 & \text{otherwise}
\end{cases}\\
B_{i,k}(x)&:= 
\frac{x - t_i}{t_{i+k} - t_i} B_{i,k-1}(x) + \frac{t_{i+k+1} - x}{t_{i+k+1} - t_{i+1}} B_{i+1,k-1}(x).
\end{align*}
where $t_i$ are the monotonic increasing *knot* points.
For this expression we actually need to extend the physical knot points, by each $k$,
so called *ghost points* in the beginning and the end, which are at the same position as 
the last/first physical knot point. 
This means, that for physical knot points ${0, .5, 1}$, 
the actual sequence including ghost-points for $k=3$ will be ${0, 0, 0, 0, .5, 1, 1, 1, 1}$.

In general: if we have $N$ physical points, we will have knot points $t_{-k}, \dots t_0, \dots t_{N-1}, t_{N}, \dots t_{N+k-1}$, where $t_i = t_0 \forall i< 0$ and $t_i=t_{N-1} \forall i\geq N$.
This means that we will have $k$ *ghost* BSplines wich are nonzero: $B_{-k,k}, \dots B_{-1, k}$.

Splines can not only interpolate functions, but they can also be used to approximately solve differential equations, 
since the derivative of the BSplines have an easy closed formula:
$$
\frac{\mathrm dB_{i,k}(x)}{\mathrm dx} = k\left(\frac{B_{i,k-1}(x)}{t_{i+k} - t_i} - \frac{B_{i+1,k-1}(x)}{t_{i+k+1} - t_{i+1}}\right).
$$
From this one can get (iteratively) the higher derivatives:
$$
\frac{\mathrm d^{n}B_{i,k}(x)}{\mathrm d^{n} x} = k\left(\frac{\partial_x^{n-1} B_{i,k-1}(x)}{t_{i+k} - t_i} - \frac{\partial_x^{n-1} B_{i+1,k-1}(x)}{t_{i+k+1} - t_{i+1}}\right).
$$ 

If we want to solve a differential equation of the form 
$$
\mathbf D f(x) = h(x)
$$
where $\mathbf D$ is a differential operator, $h(x)$ is an inhomogenity (may be zero),
and we want to solve for $f(x)$, we can use BSplines. Approximate $f(x)$ using splines
$$
f(x) = \sum_{i=-k}^{N-1} c_i B_{i,k}(x)
$$
where the $c_i$ are the unknowns, we want to solve for. 
We can then transform the differential equation into a system of linear 
equations, by requiring that the splines fulfill it exactly at the knot-points:
$$
\sum_{i=-k}^{N-1} c_i \mathbf D B_{i,k}(t_j) = h(t_j) \quad \forall 0 \leq j \leq N.
$$
Where any differential operation on the BSplines $\mathbf D B_{i,K}(x)$ is easily 
calculated with the expression above.
This system is underdetermined and we need to add boundary conditions to the system get an exact solution.
We can then write the system in matrix form 
$$
\mathbf M \vec c = \vec h
$$
which we can solve for $\vec c$. Once we found it, we can get the approximate function as given above.

In our case we have $f=\phi(r)$, $\mathbf D = \partial_r^2$ and $h=-4\pi r\rho(r)$.
The choice of the knot-points will make a huge difference in the quality of the solution, and it can be optimized 
with some knowledge about the problem.

# Numerical Implementation
Since we couldn't quickly find a (modern) C++ BSpline library, which efficiently generates 
the BSplines using standard C++ Objects (like `std::vector`), Jan and I decided to 
write a BSpline implementation ourself. 
We came up with an algorithm with an approximate time-scaling behavior of $\mathcal O\left(N+k^2\right)$,
and memory consumption of $\mathcal O\left(N+k\right)$, where $N$ is the number of knots and 
$k$ is the order of the spline. 
The algorithm uses the fact, that at any one point $x$, only $k+1$ BSplines can be non-zero.
We also implemented a function which calculates the $n$-th derivative with a similar scaling behavior.
The code is publicly available under [\color{blue}this link gist.github.com/The-Ludwig/40dcc21f5e86b1d74083a0b53f99d5f9](https://gist.github.com/The-Ludwig/40dcc21f5e86b1d74083a0b53f99d5f9).
It uses only containers from the Standard Template Library and can be easily interfaced with 
`Eigen`.
It is thoroughly documented and it is explained in detail how to use it.

We checked the correctness of our implementation against `scipy.interpolate.BSpline`, and got the same results in our tests.

The system of linear equations is solved using `<Eigen/SparseLU>`.


# Results
First we tested if the splines and their derivatives looked as we expected, the results can be seen in 
\autoref{spline} to \autoref{ddspline}. We used a test-knot sequence of $t=0, 0.1, 0.2, \dots, 1.0$.

![All different spline values for $t=0, 0.1, 0.2, \dots 1.0$. \label{spline}](build/plots/spline.pdf){ width=35% }

![All different spline derivative values for $t=0, 0.1, 0.2, \dots 1.0$.\label{dspline}](build/plots/dspline.pdf){ width=35% }

![All different spline second derivative values for $t=0, 0.1, 0.2, \dots 1.0$. \label{ddspline}](build/plots/ddspline.pdf){ width=35% }

\FloatBarrier

Now we will see if we can solve the problem at hand. For all following images $R_2=2R_1$.
We started with a sparse knot series of  $t=0, .5, 1, 1.5, 2.$, and got varying results.
The knots are also marked in the images.

![Sphere Problem with 5 knots.](build/plots/few_knots_sphere.pdf){ width=35% }

![Shell Problem with 5 knots.](build/plots/few_knots_shell.pdf){ width=35% }

![Hydrogen Problem with 5 knots.](build/plots/few_knots_hydrogen.pdf){ width=35% }


\FloatBarrier

We continue by increasing the number of points, the results are shown below. 
We see that with a 1000 knots, one can not distinguish the analytical from
the numerical solution 

![Sphere Problem with 15 knots.](build/plots/wide_few_sphere.pdf){ width=35% }

![Shell Problem with 15 knots.](build/plots/wide_few_shell.pdf){ width=35% }

![Hydrogen Problem with 15 knots.](build/plots/wide_few_hydrogen.pdf){ width=35% }

![Sphere Problem with 100 knots.](build/plots/wide_more_sphere.pdf){ width=35% }

![Shell Problem with 100 knots.](build/plots/wide_more_shell.pdf){ width=35% }

![Hydrogen Problem with 100 knots.](build/plots/wide_more_hydrogen.pdf){ width=35% }

![Sphere Problem with 1000 knots.](build/plots/wide_many_sphere.pdf){ width=35% }

![Shell Problem with 1000 knots.](build/plots/wide_many_shell.pdf){ width=35% }

![Hydrogen Problem with 1000 knots.](build/plots/wide_many_hydrogen.pdf){ width=35% }
\FloatBarrier

We observe, that if we finetune the knots we choose, then we can also get very good results 
with way fewer knots. If we add special knots shorly ($10^{-5}$) before and after 
points with discontinous charge distribution, then we get very good results with as little 
as 11 points.

![Sphere Problem with 11 finetuned knots.](build/plots/extra_knots_sphere.pdf){ width=35% }

![Shell Problem with 11 finetuned knots.](build/plots/extra_knots_shell.pdf){ width=35% }

![Hydrogen Problem with 11 finetuned knots.](build/plots/extra_knots_hydrogen.pdf){ width=35% }


# Final Remarks
Further exploring how to exactly choose the knot points, for a given problem 
could dramatically improve the accuracy. Also it is interesting how to extend this method 
to a multidimensional problem.